
===== ./types.js =====

/**
 * Type definitions for the Facebook Post Downloader extension
 * (JSDoc style for JavaScript projects)
 */

/**
 * @typedef {Object} Media
 * @property {'image' | 'video'} type - Type of media
 * @property {string} url - URL of the media file
 */

/**
 * @typedef {Object} Post
 * @property {string} id - Unique post identifier
 * @property {string} [author] - Post author name
 * @property {number} [createdTime] - Unix timestamp
 * @property {string} [text] - Post text content
 * @property {string} [group] - Group name if posted in a group
 * @property {Media[]} media - Array of media attachments
 */

/**
 * @typedef {Object} DownloadTask
 * @property {string} url - Download URL
 * @property {string} filename - Target filename with path
 * @property {string} postId - Associated post ID
 * @property {number} tabId - Tab ID for notifications
 * @property {number} retries - Number of retry attempts
 * @property {boolean} [isBlob] - Whether URL is a blob
 */

/**
 * @typedef {Object} DownloadProgress
 * @property {number} completed - Number of completed downloads
 * @property {number} total - Total number of downloads
 */

/**
 * @typedef {Object} ExtensionMessage
 * @property {boolean} __EXT__ - Extension message identifier
 * @property {string} type - Message type
 * @property {*} payload - Message payload
 */

export {};


===== ./background\index.js =====

// Background Service Worker
console.log("[Background] Service worker starting...");

const MAX_CONCURRENT_DOWNLOADS = 3;
const downloadQueue = [];
const activeDownloads = new Map();

// Message handler
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log(
    "[Background] Received message:",
    message.type,
    "from tab:",
    sender.tab?.id
  );

  try {
    if (message.type === "DOWNLOAD") {
      handleDownload(message.payload, sender.tab.id);
      sendResponse({ success: true });
      return true;
    } else if (message.type === "UPDATE_BADGE") {
      updateBadge(message.payload);
      sendResponse({ success: true });
      return true;
    } else if (message.type === "GET_DOWNLOAD_STATUS") {
      sendResponse({
        queue: downloadQueue.length,
        active: activeDownloads.size,
      });
      return true;
    } else if (message.type === "POSTS_DETECTED") {
      console.log(
        "[Background] Posts detected:",
        message.payload?.posts?.length || 0
      );
      sendResponse({ success: true, received: true });
      return true;
    } else {
      console.log("[Background] Unknown message type:", message.type);
      sendResponse({ success: true, unknown: true });
      return true;
    }
  } catch (error) {
    console.error("[Background] Error handling message:", error);
    sendResponse({ success: false, error: error.message });
    return true;
  }
});

// Handle download request
async function handleDownload(payload, tabId) {
  console.log(
    "[Background] Handling download for",
    payload.posts?.length || 0,
    "posts"
  );

  const { posts } = payload;

  for (const post of posts) {
    // ALWAYS create metadata file for every post
    const metadata = generateMetadata(post);
    const metadataBlob = new Blob([metadata], { type: "text/markdown" });
    const metadataUrl = URL.createObjectURL(metadataBlob);
    downloadQueue.push({
      url: metadataUrl,
      filename: generateFilename(post, { type: "metadata" }, 0),
      postId: post.id,
      tabId: tabId,
      retries: 0,
      isBlob: true,
    });
    console.log("[Background] Queued metadata file for post:", post.id);

    // Download media if post has any
    if (post.media && post.media.length > 0) {
      for (let i = 0; i < post.media.length; i++) {
        const media = post.media[i];
        const downloadTask = {
          url: media.url,
          filename: generateFilename(post, media, i),
          postId: post.id,
          tabId: tabId,
          retries: 0,
        };
        downloadQueue.push(downloadTask);
        console.log(
          "[Background] Queued media download:",
          downloadTask.filename
        );
      }
    } else {
      console.log(
        "[Background] Post has no media, only creating metadata file"
      );
    }
  }

  console.log("[Background] Total in queue:", downloadQueue.length);
  processQueue();
}

// Process download queue
async function processQueue() {
  console.log("[Background] Processing queue...", {
    queue: downloadQueue.length,
    active: activeDownloads.size,
    maxConcurrent: MAX_CONCURRENT_DOWNLOADS,
  });

  while (
    downloadQueue.length > 0 &&
    activeDownloads.size < MAX_CONCURRENT_DOWNLOADS
  ) {
    const task = downloadQueue.shift();
    startDownload(task);
  }
}

// Start individual download
async function startDownload(task) {
  console.log("[Background] Starting download:", task.filename);

  try {
    const downloadId = await chrome.downloads.download({
      url: task.url,
      filename: task.filename,
      conflictAction: "uniquify",
    });

    console.log("[Background] Download started with ID:", downloadId);
    activeDownloads.set(downloadId, task);

    // Notify content script
    chrome.tabs
      .sendMessage(task.tabId, {
        type: "DOWNLOAD_STARTED",
        payload: { postId: task.postId, downloadId },
      })
      .catch((err) => {
        console.log(
          "[Background] Could not notify tab (tab may be closed):",
          err.message
        );
      });
  } catch (error) {
    console.error("[Background] Download failed:", error);

    // Retry logic
    if (task.retries < 3) {
      task.retries++;
      console.log("[Background] Retrying download (attempt", task.retries, ")");
      downloadQueue.push(task);
      setTimeout(processQueue, 2000);
    } else {
      console.error(
        "[Background] Download failed after 3 retries:",
        task.filename
      );
      // Notify failure
      chrome.tabs
        .sendMessage(task.tabId, {
          type: "DOWNLOAD_FAILED",
          payload: { postId: task.postId, error: error.message },
        })
        .catch(() => {});
    }
  }
}

// Listen for download completion
chrome.downloads.onChanged.addListener((delta) => {
  if (delta.state && delta.state.current === "complete") {
    const task = activeDownloads.get(delta.id);
    if (task) {
      console.log("[Background] Download completed:", task.filename);
      activeDownloads.delete(delta.id);

      // Cleanup blob URLs
      if (task.isBlob) {
        URL.revokeObjectURL(task.url);
      }

      // Notify content script
      chrome.tabs
        .sendMessage(task.tabId, {
          type: "DOWNLOAD_COMPLETE",
          payload: { postId: task.postId, downloadId: delta.id },
        })
        .catch(() => {});

      // Process next in queue
      processQueue();
    }
  } else if (delta.state && delta.state.current === "interrupted") {
    const task = activeDownloads.get(delta.id);
    if (task) {
      console.error("[Background] Download interrupted:", task.filename);
      activeDownloads.delete(delta.id);

      // Retry
      if (task.retries < 3) {
        task.retries++;
        downloadQueue.push(task);
        setTimeout(processQueue, 2000);
      }
    }
  }
});

// Generate safe filename
function generateFilename(post, media, index) {
  const date = post.createdTime
    ? new Date(post.createdTime * 1000)
    : new Date();
  const dateStr = date.toISOString().split("T")[0];
  const author = sanitizeFilename(post.author || "unknown");
  const postIdShort = post.id ? post.id.slice(-8) : "unknown";

  if (media.type === "metadata") {
    return `facebook_downloads/${dateStr}_${author}_${postIdShort}/index.md`;
  }

  const ext = media.type === "video" ? "mp4" : "jpg";
  const suffix = index > 0 ? `_${index}` : "";

  return `facebook_downloads/${dateStr}_${author}_${postIdShort}/${media.type}${suffix}.${ext}`;
}

// Sanitize filename
function sanitizeFilename(str) {
  return str
    .replace(/[^a-z0-9]/gi, "_")
    .replace(/_+/g, "_")
    .substring(0, 50)
    .toLowerCase();
}

// Generate metadata
function generateMetadata(post) {
  let md = `# Facebook Post\n\n`;
  md += `**Post ID:** ${post.id || "N/A"}\n`;
  md += `**Author:** ${post.author || "N/A"}\n`;
  md += `**Created:** ${
    post.createdTime ? new Date(post.createdTime * 1000).toISOString() : "N/A"
  }\n`;
  if (post.group) md += `**Group:** ${post.group}\n`;
  md += `\n## Content\n\n`;
  md += post.text || "(No text content)";
  md += `\n\n## Media\n\n`;
  if (post.media && post.media.length > 0) {
    post.media.forEach((m, i) => {
      md += `- ${m.type} ${i + 1}: ${m.url}\n`;
    });
  } else {
    md += "(No media attachments)\n";
  }
  return md;
}

// Update badge
function updateBadge(count) {
  if (count > 0) {
    chrome.action.setBadgeText({ text: count.toString() });
    chrome.action.setBadgeBackgroundColor({ color: "#4CAF50" });
  } else {
    chrome.action.setBadgeText({ text: "" });
  }
}

console.log("[Background] Service worker initialized and ready!");

// Self-test on startup
setTimeout(() => {
  console.log("[Background] Self-test: Service worker is alive");
}, 1000);


===== ./content\main.jsx =====

import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import DownloaderApp from "./views/DownloaderApp";

console.log("[Facebook Downloader] Content script START");
console.log("[Facebook Downloader] Location:", window.location.href);
console.log("[Facebook Downloader] Document state:", document.readyState);

// Check if extension context is valid
function isExtensionContextValid() {
  try {
    return !!chrome.runtime?.id;
  } catch (e) {
    return false;
  }
}

// Inject page script
function injectPageScript() {
  if (!isExtensionContextValid()) {
    console.error("[Facebook Downloader] Extension context invalid");
    return;
  }

  try {
    const script = document.createElement("script");
    // Use the new GraphQL interceptor
    script.src = chrome.runtime.getURL("src/injected/graphql-interceptor.js");
    script.type = "module";
    script.onload = () => {
      console.log(
        "[Facebook Downloader] GraphQL interceptor injected successfully"
      );
      script.remove();
    };
    script.onerror = (error) => {
      console.error(
        "[Facebook Downloader] GraphQL interceptor injection failed:",
        error
      );
    };

    const target = document.head || document.documentElement;
    if (target) {
      target.appendChild(script);
      console.log(
        "[Facebook Downloader] GraphQL interceptor element added to",
        target.tagName
      );
    }
  } catch (error) {
    console.error(
      "[Facebook Downloader] Error injecting GraphQL interceptor:",
      error
    );
  }
}

// Message bridge
window.addEventListener("message", (event) => {
  if (event.source !== window) return;

  const message = event.data;

  if (message && message.__EXT__ === true) {
    console.log("[Facebook Downloader] Message from page:", message.type);

    if (!isExtensionContextValid()) {
      console.error("[Facebook Downloader] ‚ùå Extension context invalid!");
      return;
    }

    chrome.runtime
      .sendMessage({
        type: message.type,
        payload: message.payload,
      })
      .then((response) => {
        console.log(
          "[Facebook Downloader] Response from background:",
          response
        );
        if (response) {
          window.postMessage(
            {
              __EXT__: true,
              type: `${message.type}_RESPONSE`,
              payload: response,
            },
            "*"
          );
        }
      })
      .catch((err) => {
        console.error("[Facebook Downloader] Message error:", err.message);
      });
  }
});

// Listen for messages from background
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log("[Facebook Downloader] Message from background:", message.type);
  window.postMessage(
    {
      __EXT__: true,
      type: message.type,
      payload: message.payload,
    },
    "*"
  );
  sendResponse({ received: true });
  return true;
});

// Create UI
function initializeUI() {
  console.log("[Facebook Downloader] Initializing UI...");

  if (!document.body) {
    setTimeout(initializeUI, 100);
    return;
  }

  if (document.getElementById("fb-downloader-root")) {
    console.log("[Facebook Downloader] UI already initialized");
    return;
  }

  try {
    const container = document.createElement("div");
    container.id = "fb-downloader-root";
    // CRITICAL: Set attributes to prevent React conflicts
    container.setAttribute("data-reactroot", "");
    container.style.cssText =
      "all: initial; * { all: unset; } position: fixed !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; pointer-events: none !important; z-index: 2147483647 !important;";

    console.log("[Facebook Downloader] Appending container to body");
    document.body.appendChild(container);

    console.log("[Facebook Downloader] Creating React root");
    const root = createRoot(container);

    console.log("[Facebook Downloader] Rendering React app");
    root.render(<DownloaderApp />);

    console.log("[Facebook Downloader] ‚úÖ UI initialized successfully");

    setTimeout(() => {
      const check = document.getElementById("fb-downloader-root");
      console.log(
        "[Facebook Downloader] DOM check:",
        check ? "‚úÖ Found" : "‚ùå Not found"
      );

      const button = document.querySelector(".fb-dl-toggle");
      console.log(
        "[Facebook Downloader] Button check:",
        button ? "‚úÖ Found" : "‚ùå Not found"
      );

      if (button) {
        console.log("[Facebook Downloader] üéâ Button is visible!");
      }
    }, 1000);
  } catch (error) {
    console.error("[Facebook Downloader] ‚ùå Error initializing UI:", error);
  }
}

// Initialize
console.log("[Facebook Downloader] Starting initialization...");

if (!isExtensionContextValid()) {
  console.error("[Facebook Downloader] ‚ùå Extension context invalid!");
} else {
  injectPageScript();

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeUI);
  } else {
    initializeUI();
  }

  setTimeout(() => {
    if (!document.getElementById("fb-downloader-root")) {
      console.log("[Facebook Downloader] Fallback init");
      initializeUI();
    }
  }, 2000);
}

console.log("[Facebook Downloader] Content script END");


===== ./content\views\DownloaderApp.css =====

.fb-dl-toggle {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 999999;
}

.fb-dl-toggle-btn {
  background: #1877f2;
  color: white;
  border: none;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  font-size: 24px;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  transition: all 0.3s;
}

.fb-dl-toggle-btn:hover {
  background: #145dbf;
  transform: scale(1.1);
}

.fb-dl-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 999999;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
    Arial, sans-serif;
}

.fb-dl-panel {
  background: white;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  width: 900px;
  max-width: 90vw;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.fb-dl-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #e4e6eb;
  background: #f5f6f7;
}

.fb-dl-header h2 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #1c1e21;
}

.fb-dl-close {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #65676b;
  padding: 0;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  transition: background 0.2s;
}

.fb-dl-close:hover {
  background: #e4e6eb;
}

.fb-dl-stats {
  display: flex;
  gap: 20px;
  padding: 12px 20px;
  background: #f5f6f7;
  border-bottom: 1px solid #e4e6eb;
  font-size: 14px;
  color: #65676b;
}

.fb-dl-progress {
  padding: 12px 20px;
  background: #e7f3ff;
  border-bottom: 1px solid #e4e6eb;
}

.fb-dl-progress-bar {
  width: 100%;
  height: 8px;
  background: #d0e7ff;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 8px;
}

.fb-dl-progress-fill {
  height: 100%;
  background: #1877f2;
  transition: width 0.3s;
}

.fb-dl-progress span {
  font-size: 13px;
  color: #1877f2;
  font-weight: 500;
}

.fb-dl-controls {
  display: flex;
  gap: 12px;
  padding: 16px 20px;
  border-bottom: 1px solid #e4e6eb;
}

.fb-dl-controls button {
  padding: 8px 16px;
  border: 1px solid #ccd0d5;
  background: white;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.fb-dl-controls button:hover:not(:disabled) {
  background: #f5f6f7;
}

.fb-dl-controls button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.fb-dl-download-btn {
  background: #1877f2 !important;
  color: white !important;
  border: none !important;
}

.fb-dl-download-btn:hover:not(:disabled) {
  background: #145dbf !important;
}

.fb-dl-posts {
  flex: 1;
  overflow-y: auto;
  padding: 0;
}

.fb-dl-empty {
  padding: 40px 20px;
  text-align: center;
  color: #65676b;
  font-size: 14px;
}

.fb-dl-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

.fb-dl-table thead {
  background: #f5f6f7;
  position: sticky;
  top: 0;
  z-index: 1;
}

.fb-dl-table th {
  padding: 12px 16px;
  text-align: left;
  font-weight: 600;
  color: #1c1e21;
  border-bottom: 1px solid #e4e6eb;
}

.fb-dl-table td {
  padding: 12px 16px;
  border-bottom: 1px solid #e4e6eb;
  color: #1c1e21;
}

.fb-dl-table tbody tr:hover {
  background: #f5f6f7;
}

.fb-dl-table tbody tr.selected {
  background: #e7f3ff;
}

.fb-dl-text-preview {
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: #65676b;
}

.fb-dl-media-types {
  margin-left: 4px;
  font-size: 12px;
}

input[type="checkbox"] {
  cursor: pointer;
  width: 18px;
  height: 18px;
}

/* Auto-scroll section */
.fb-dl-autoscroll {
  padding: 12px 20px;
  background: #e7f3ff;
  border-bottom: 1px solid #e4e6eb;
}

.fb-dl-section-title {
  font-size: 14px;
  font-weight: 600;
  color: #1c1e21;
  margin-bottom: 8px;
}

.fb-dl-scroll-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.fb-dl-btn-start {
  background: #4caf50 !important;
  color: white !important;
  border: none !important;
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 13px;
  cursor: pointer;
}

.fb-dl-btn-start:disabled {
  background: #9e9e9e !important;
  cursor: not-allowed;
}

.fb-dl-btn-pause {
  background: #ff9800 !important;
  color: white !important;
  border: none !important;
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 13px;
  cursor: pointer;
}

.fb-dl-btn-pause:disabled {
  background: #9e9e9e !important;
  cursor: not-allowed;
}

.fb-dl-btn-stop {
  background: #f44336 !important;
  color: white !important;
  border: none !important;
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 13px;
  cursor: pointer;
}

.fb-dl-btn-stop:disabled {
  background: #9e9e9e !important;
  cursor: not-allowed;
}

.fb-dl-scroll-status {
  margin-left: auto;
  font-size: 13px;
  color: #65676b;
}

.fb-dl-scroll-status strong {
  color: #1877f2;
  text-transform: uppercase;
}

/* Filters section */
.fb-dl-filters {
  padding: 12px 20px;
  background: #f5f6f7;
  border-bottom: 1px solid #e4e6eb;
}

.fb-dl-filter-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 12px;
  margin-top: 8px;
}

.fb-dl-filter-item {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.fb-dl-filter-item label {
  font-size: 12px;
  font-weight: 500;
  color: #65676b;
}

.fb-dl-filter-item input[type="text"],
.fb-dl-filter-item input[type="number"],
.fb-dl-filter-item select {
  padding: 6px 8px;
  border: 1px solid #ccd0d5;
  border-radius: 4px;
  font-size: 13px;
  background: white;
  color: #1c1e21;
}

.fb-dl-filter-item input[type="text"]:focus,
.fb-dl-filter-item input[type="number"]:focus,
.fb-dl-filter-item select:focus {
  outline: none;
  border-color: #1877f2;
  box-shadow: 0 0 0 2px rgba(24, 119, 242, 0.1);
}

.fb-dl-btn-clear {
  padding: 6px 12px;
  background: #f44336;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  cursor: pointer;
  margin-top: 18px;
}

.fb-dl-btn-clear:hover {
  background: #d32f2f;
}

/* Export buttons */
.fb-dl-export-btn {
  background: #4caf50 !important;
  color: white !important;
  border: none !important;
}

.fb-dl-export-btn:hover:not(:disabled) {
  background: #45a049 !important;
}

.fb-dl-export-btn:disabled {
  background: #9e9e9e !important;
}


===== ./content\views\DownloaderApp.jsx =====

import { useState, useEffect, useRef } from "react";
import "./DownloaderApp.css";

console.log("[DownloaderApp] Component loading");

export default function DownloaderApp() {
  console.log("[DownloaderApp] Component rendering");
  const [show, setShow] = useState(false);
  const [posts, setPosts] = useState([]);
  const [selected, setSelected] = useState(new Set());
  const [downloading, setDownloading] = useState(false);
  const [progress, setProgress] = useState({ completed: 0, total: 0 });

  // Auto-scroll states
  const [isScrolling, setIsScrolling] = useState(false);
  const [scrollStatus, setScrollStatus] = useState("idle");
  const [scrollSpeed, setScrollSpeed] = useState(500); // pixels per scroll

  // Filter states
  const [timeFilter, setTimeFilter] = useState(""); // e.g., "10m", "2h", "1d"
  const [keywordFilter, setKeywordFilter] = useState(
    "‡¶Æ‡¶æ‡¶∂‡¶æ‡¶≤‡ßç‡¶≤‡¶æ‡¶π, ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø, ‡¶ï‡ßá‡¶®‡¶æ, ‡¶∏‡ßá‡¶≤, ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º, ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø, ‡¶¶‡¶æ‡¶Æ, ‡¶¨‡¶æ‡¶∏‡¶æ ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶è‡¶ï‡¶¶‡¶æ‡¶Æ, ‡¶∏‡¶ø‡¶ü ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®, ‡¶¨‡¶æ‡¶∏‡¶æ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®, ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®, ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶æ‡¶®, ‡¶≠‡¶æ‡¶∞‡¶æ ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶≠‡¶æ‡¶∞‡¶æ ‡¶≤‡¶æ‡¶ó‡¶¨, ‡¶≠‡¶æ‡¶°‡¶º‡¶æ ‡¶≤‡¶æ‡¶ó‡¶¨, ‡¶ï‡¶ø‡¶®‡¶§‡ßá, ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º, Sell, welcome, ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶¶‡¶∏‡ßç‡¶Ø, ‡¶Æ‡¶ß‡ßÅ, ‡¶∏‡ßá‡¶≤‡¶æ‡¶∞‡¶ø, Off topic, ‡¶™‡¶æ‡¶∞‡ßç‡¶ü ‡¶ü‡¶æ‡¶á‡¶Æ, ‡¶≠‡¶æ‡¶á‡¶∞‡¶æ‡¶≤_‡¶≠‡¶ø‡¶°‡¶ø‡¶ì, ‡¶∞‡ßÅ‡¶Æ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞, ‡¶¶‡ßÅ‡¶ß, ‡¶Ü‡¶Æ‡¶ø‡¶®, ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞, ‡¶°‡ßá‡¶á‡¶∞‡¶ø ‡¶´‡¶æ‡¶∞‡ßç‡¶Æ, ‡¶°‡ßç‡¶∞‡ßá‡¶∏, youtu.be, ‡¶ì‡¶°‡¶º‡¶®‡¶æ, projon, ‡¶®‡¶ø‡¶Ø‡¶º‡ßã‡¶ó, ‡¶∏‡ßÇ‡¶∞‡¶æ, ‡¶™‡¶°‡¶º‡¶æ‡¶ö‡ßç‡¶õ‡¶ø, ‡¶ï‡ßã‡¶ö‡¶ø‡¶Ç, ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°, ‡¶∂‡ßÅ‡¶≠ ‡¶∞‡¶æ‡¶§‡ßç‡¶∞‡¶ø, ‡¶á‡¶®‡¶ï‡¶æ‡¶Æ, ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º, ‡¶¨‡¶æ‡¶∏‡¶æ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞, ‡¶∏‡ßá‡¶≤, ‡¶°‡ßá‡¶≤‡¶ø‡¶≠‡¶æ‡¶∞‡¶ø, ‡¶∏‡ßã‡¶´‡¶æ ‡¶ï‡ßç‡¶≤‡¶ø‡¶®‡¶ø‡¶Ç, ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ ‡¶™‡ßá‡¶§‡ßá, follow back, ùôÅùô§ùô°ùô°ùô§ùô¨ ùòΩùôñùôòùô†, ‡¶¶‡ßã‡¶Ø‡¶º‡¶æ, ‡¶ú‡¶æ‡¶§‡ßÄ‡¶Ø‡¶º ‡¶™‡¶æ‡¶ñ‡¶ø, ‡¶¶‡ßá‡¶∂‡ßá‡¶∞, room dorkar, bmw, ‡¶∏‡¶∞‡¶ï‡¶æ‡¶∞, ‡¶Æ‡¶ø‡¶≤‡ßç‡¶ï ‡¶∂‡ßá‡¶ï, ‡¶π‡¶æ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá ‡¶ó‡ßá‡¶õ‡ßá, ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶®, ‡¶Ü‡¶≤‡ßç‡¶≤‡¶æ‡¶π, ‡¶™‡ßç‡¶∞‡¶Æ‡ßã‡¶∂‡¶®‡¶æ‡¶≤ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏‡¶ø‡¶Ç, Offer, ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶•‡¶æ‡¶ï‡¶ø, ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá, Rent a car, RAM ‡¶Ø‡ßÅ‡¶¶‡ßç‡¶ß, ‡¶à‡¶¶‡ßá‡¶∞, Page, ‡¶Æ‡ßá‡¶π‡ßá‡¶¶‡ßÄ, ‡¶ï‡ßç‡¶∞‡¶ø‡¶Æ, with a Facebook Post:, Sale, mAh, ‡¶¨‡ßá‡¶§‡¶®, teacher, ‡¶™‡¶æ‡¶á‡¶ï‡¶æ‡¶∞‡¶ø, ‡¶™‡ßç‡¶∞‡¶æ‡¶ï‡¶ü‡¶ø‡¶ï‡¶æ‡¶≤"
  );

  // Draggable states
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [isInitialized, setIsInitialized] = useState(false);

  const scrollIntervalRef = useRef(null);
  const panelRef = useRef(null);

  // Center the panel on first show
  useEffect(() => {
    if (show && !isInitialized && panelRef.current) {
      // Use setTimeout to ensure the panel is fully rendered
      setTimeout(() => {
        const panel = panelRef.current;
        if (!panel) return;

        const rect = panel.getBoundingClientRect();

        setPosition({
          x: Math.max(0, (window.innerWidth - rect.width) / 2),
          y: Math.max(0, (window.innerHeight - rect.height) / 2),
        });
        setIsInitialized(true);
      }, 0);
    }
  }, [show, isInitialized]);

  // Parse time filter (e.g., "10m" -> 600 seconds)
  const parseTimeFilter = (filterStr) => {
    if (!filterStr || filterStr.trim() === "") return null;

    const match = filterStr.match(/^(\d+)([smhd])$/i);
    if (!match) return null;

    const value = parseInt(match[1]);
    const unit = match[2].toLowerCase();

    const multipliers = {
      s: 1,
      m: 60,
      h: 3600,
      d: 86400,
    };

    return value * (multipliers[unit] || 0);
  };

  // Check if post passes time filter
  const passesTimeFilter = (post) => {
    const filterSeconds = parseTimeFilter(timeFilter);
    if (!filterSeconds) return true; // No filter = pass all

    const now = Math.floor(Date.now() / 1000);
    const postTime = post.createdTime || 0;

    // If post has no valid timestamp, filter it out when time filter is active
    if (!postTime || postTime === 0) {
      console.log(
        `[Filter] Post has no timestamp, filtering out: ${post.id?.substring(
          0,
          20
        )}`
      );
      return false;
    }

    // Calculate how long ago the post was created
    const postAge = now - postTime;

    // Calculate the cutoff time (now minus filter duration)
    const cutoffTime = now - filterSeconds;

    console.log(
      `[Filter] Time check - Post time: ${new Date(
        postTime * 1000
      ).toLocaleString()}, Cutoff: ${new Date(
        cutoffTime * 1000
      ).toLocaleString()}, Age: ${Math.floor(postAge / 60)}min`
    );

    // Post passes if it was posted AFTER the cutoff time (within the time range)
    // In other words: postTime must be >= cutoffTime
    const passes = postTime >= cutoffTime;

    if (!passes) {
      console.log(
        `[Filter] ‚è≠Ô∏è Post too old: ${Math.floor(
          postAge / 60
        )}min ago (limit: ${Math.floor(filterSeconds / 60)}min)`
      );
    }

    return passes;
  };

  // Check if post passes keyword filter
  const passesKeywordFilter = (post) => {
    if (!keywordFilter.trim()) return true;

    const keywords = keywordFilter
      .split(",")
      .map((k) => k.trim().toLowerCase())
      .filter((k) => k.length > 0);

    if (keywords.length === 0) return true;

    const postText = (post.text || "").toLowerCase();

    // Return false if ANY keyword is found (filter out)
    return !keywords.some((keyword) => postText.includes(keyword));
  };

  // Apply all filters to posts
  const filterPosts = (postsArray) => {
    return postsArray.filter((post) => {
      // Must have text
      if (!post.text || post.text.trim().length === 0) return false;

      // Check time filter
      if (!passesTimeFilter(post)) {
        console.log(
          `[Filter] Time filter removed post: ${post.id.substring(0, 20)}`
        );
        return false;
      }

      // Check keyword filter
      if (!passesKeywordFilter(post)) {
        console.log(
          `[Filter] Keyword filter removed post: ${post.id.substring(0, 20)}`
        );
        return false;
      }

      return true;
    });
  };

  useEffect(() => {
    console.log("[DownloaderApp] useEffect mounted");

    // Listen for messages from page script
    const handleMessage = (event) => {
      if (event.source !== window) return;
      const message = event.data;

      if (message && message.__EXT__ === true) {
        switch (message.type) {
          case "POSTS_DETECTED":
            const filteredPosts = filterPosts(message.payload.posts);
            console.log(
              `[DownloaderApp] Filtered ${message.payload.posts.length} posts down to ${filteredPosts.length} posts`
            );
            setPosts(filteredPosts);
            break;
          case "DOWNLOAD_STARTED":
            setDownloading(true);
            break;
          case "DOWNLOAD_COMPLETE":
            setProgress((prev) => ({ ...prev, completed: prev.completed + 1 }));
            break;
          case "DOWNLOAD_FAILED":
            console.error("Download failed:", message.payload);
            break;
          case "ALL_DOWNLOADS_COMPLETE":
            setDownloading(false);
            setProgress({ completed: 0, total: 0 });
            setSelected(new Set());
            break;
          case "EXTENSION_INVALIDATED":
            alert(
              message.payload.message +
                "\n\nPress Ctrl+R (or Cmd+R on Mac) to refresh."
            );
            break;
        }
      }
    };

    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, [timeFilter, keywordFilter]);

  // Dragging functionality
  useEffect(() => {
    const handleMouseMove = (e) => {
      if (!isDragging) return;

      setPosition({
        x: e.clientX - dragOffset.x,
        y: e.clientY - dragOffset.y,
      });
    };

    const handleMouseUp = () => {
      setIsDragging(false);
    };

    if (isDragging) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    }

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [isDragging, dragOffset]);

  const handleMouseDown = (e) => {
    // Only allow dragging from the header, not from buttons or inputs
    const target = e.target;
    if (!target.closest(".fb-dl-header")) return;
    if (target.closest(".fb-dl-close")) return;
    if (target.tagName === "BUTTON") return;
    if (target.tagName === "INPUT") return;

    const panel = panelRef.current;
    if (!panel) return;

    const rect = panel.getBoundingClientRect();
    setDragOffset({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    });
    setIsDragging(true);
    e.preventDefault(); // Prevent text selection while dragging
  };

  // Auto-scroll functionality
  const startAutoScroll = () => {
    setScrollStatus("running");
    setIsScrolling(true);

    scrollIntervalRef.current = setInterval(() => {
      window.scrollBy({
        top: scrollSpeed,
        behavior: "smooth",
      });

      if (
        window.innerHeight + window.scrollY >=
        document.body.offsetHeight - 100
      ) {
        pauseAutoScroll();
      }
    }, 2000);
  };

  const pauseAutoScroll = () => {
    if (scrollIntervalRef.current) {
      clearInterval(scrollIntervalRef.current);
      scrollIntervalRef.current = null;
    }
    setScrollStatus("paused");
    setIsScrolling(false);
  };

  const stopAutoScroll = () => {
    if (scrollIntervalRef.current) {
      clearInterval(scrollIntervalRef.current);
      scrollIntervalRef.current = null;
    }
    setScrollStatus("stopped");
    setIsScrolling(false);
  };

  const clearAllPosts = () => {
    if (window.confirm("Are you sure you want to clear all detected posts?")) {
      setPosts([]);
      setSelected(new Set());
      console.log("[DownloaderApp] All posts cleared");
    }
  };

  const togglePost = (postId) => {
    setSelected((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(postId)) {
        newSet.delete(postId);
      } else {
        newSet.add(postId);
      }
      return newSet;
    });
  };

  const selectAll = () => {
    if (selected.size === posts.length) {
      setSelected(new Set());
    } else {
      setSelected(new Set(posts.map((p) => p.id)));
    }
  };

  const handleDownload = () => {
    const selectedPosts = posts.filter((p) => selected.has(p.id));
    if (selectedPosts.length === 0) return;

    const totalMedia = selectedPosts.reduce(
      (acc, p) => acc + (p.media?.length || 0),
      0
    );
    setProgress({ completed: 0, total: totalMedia });

    window.postMessage(
      {
        __EXT__: true,
        type: "DOWNLOAD",
        payload: { posts: selectedPosts },
      },
      "*"
    );
  };

  const exportToJSON = () => {
    const selectedPosts = posts.filter((p) => selected.has(p.id));
    const dataStr = JSON.stringify(selectedPosts, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `facebook_posts_${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const exportToCSV = () => {
    const selectedPosts = posts.filter((p) => selected.has(p.id));

    let csv = "ID,Author,Date,Text,Media Count,Media Types,Media URLs\n";

    selectedPosts.forEach((post) => {
      const date = post.createdTime
        ? new Date(post.createdTime * 1000).toISOString()
        : "Unknown";
      const text = (post.text || "").replace(/"/g, '""').replace(/\n/g, " ");
      const mediaCount = post.media?.length || 0;
      const mediaTypes = post.media?.map((m) => m.type).join("; ") || "";
      const mediaUrls = post.media?.map((m) => m.url).join("; ") || "";

      csv += `"${post.id}","${
        post.author || ""
      }","${date}","${text}",${mediaCount},"${mediaTypes}","${mediaUrls}"\n`;
    });

    const dataBlob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `facebook_posts_${Date.now()}.csv`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return "Unknown";
    const date = new Date(timestamp * 1000);
    return date.toLocaleDateString() + " " + date.toLocaleTimeString();
  };

  // Calculate time progress (how old is the post relative to the filter)
  const getTimeProgress = (timestamp) => {
    const filterSeconds = parseTimeFilter(timeFilter);
    if (!filterSeconds || !timestamp) return null;

    const now = Math.floor(Date.now() / 1000);
    const postAge = now - timestamp;

    // Calculate percentage (0% = filter limit ago, 100% = just posted)
    // Invert it so NEW posts = 100% (full bar), OLD posts = 0% (empty bar)
    const percentage = Math.max(0, 100 - (postAge / filterSeconds) * 100);

    return {
      percentage,
      age: postAge,
      ageText: formatTimeAge(postAge),
    };
  };

  // Format age in human-readable form
  const formatTimeAge = (seconds) => {
    if (seconds < 60) return `${Math.floor(seconds)}s ago`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    return `${Math.floor(seconds / 86400)}d ago`;
  };

  if (!show) {
    console.log("[DownloaderApp] Rendering toggle button");
    return (
      <div className="fb-dl-toggle" style={{ pointerEvents: "auto" }}>
        <button className="fb-dl-toggle-btn" onClick={() => setShow(true)}>
          üì• {posts.length > 0 && `(${posts.length})`}
        </button>
      </div>
    );
  }

  return (
    <div
      className="fb-dl-container"
      style={{
        pointerEvents: "auto",
        position: "fixed",
        left: isInitialized ? `${position.x}px` : "50%",
        top: isInitialized ? `${position.y}px` : "50%",
        transform: isInitialized ? "none" : "translate(-50%, -50%)",
        right: "auto",
        bottom: "auto",
      }}
    >
      <div
        className="fb-dl-panel"
        ref={panelRef}
        onMouseDown={handleMouseDown}
        style={{ cursor: isDragging ? "grabbing" : "default" }}
      >
        <div
          className="fb-dl-header"
          style={{ cursor: "grab", userSelect: "none" }}
        >
          <h2 style={{ margin: 0, fontSize: "18px" }}>
            Facebook Post Downloader
          </h2>
          <button className="fb-dl-close" onClick={() => setShow(false)}>
            ‚úï
          </button>
        </div>

        {/* Auto-scroll controls */}
        <div className="fb-dl-autoscroll">
          <div className="fb-dl-section-title">üîÑ Auto-Scroll</div>
          <div className="fb-dl-scroll-controls">
            <button
              onClick={startAutoScroll}
              disabled={isScrolling || scrollStatus === "running"}
              className="fb-dl-btn-start"
            >
              ‚ñ∂Ô∏è Start
            </button>
            <button
              onClick={pauseAutoScroll}
              disabled={!isScrolling}
              className="fb-dl-btn-pause"
            >
              ‚è∏Ô∏è Pause
            </button>
            <button
              onClick={stopAutoScroll}
              disabled={scrollStatus === "idle"}
              className="fb-dl-btn-stop"
            >
              ‚èπÔ∏è Stop
            </button>
            <span className="fb-dl-scroll-status">
              Status: <strong>{scrollStatus}</strong>
            </span>
          </div>
          <div
            style={{
              marginTop: "8px",
              display: "flex",
              alignItems: "center",
              gap: "8px",
            }}
          >
            <label
              style={{ display: "flex", alignItems: "center", gap: "5px" }}
            >
              Speed:
              <input
                type="number"
                value={scrollSpeed}
                onChange={(e) =>
                  setScrollSpeed(Math.max(100, parseInt(e.target.value) || 500))
                }
                style={{ width: "70px" }}
                min="100"
                max="2000"
                step="100"
              />
              px
            </label>
          </div>
        </div>

        {/* Filters */}
        <div className="fb-dl-filters">
          <div className="fb-dl-section-title">üîç Filters</div>

          <div className="fb-dl-filter-row">
            <label>
              Time Filter:
              <input
                type="text"
                value={timeFilter}
                onChange={(e) => setTimeFilter(e.target.value)}
                placeholder="e.g., 10m, 2h, 1d"
                style={{ width: "100px", marginLeft: "5px" }}
              />
            </label>
            <small style={{ marginLeft: "10px", color: "#666" }}>
              (m=minutes, h=hours, d=days)
            </small>
          </div>

          <div className="fb-dl-filter-row">
            <label style={{ display: "block", marginBottom: "5px" }}>
              Keyword Filter (comma-separated):
            </label>
            <textarea
              value={keywordFilter}
              onChange={(e) => setKeywordFilter(e.target.value)}
              rows="3"
              style={{ width: "100%", fontSize: "12px" }}
              placeholder="Posts containing these keywords will be filtered out"
            />
          </div>
        </div>

        <div className="fb-dl-stats">
          <span>Total posts: {posts.length}</span>
          <span>Selected: {selected.size}</span>
        </div>

        {downloading && (
          <div className="fb-dl-progress">
            <div className="fb-dl-progress-bar">
              <div
                className="fb-dl-progress-fill"
                style={{
                  width: `${(progress.completed / progress.total) * 100}%`,
                }}
              />
            </div>
            <span>
              {progress.completed} / {progress.total} files
            </span>
          </div>
        )}

        <div className="fb-dl-controls">
          <button onClick={selectAll} disabled={downloading}>
            {selected.size === posts.length ? "Deselect All" : "Select All"}
          </button>
          <button
            onClick={clearAllPosts}
            disabled={downloading || posts.length === 0}
            className="fb-dl-clear-btn"
            style={{ backgroundColor: "#dc3545" }}
          >
            üóëÔ∏è Clear All
          </button>
          <button
            onClick={handleDownload}
            disabled={selected.size === 0 || downloading}
            className="fb-dl-download-btn"
          >
            üì• Download Media ({selected.size})
          </button>
          <button
            onClick={exportToJSON}
            disabled={selected.size === 0}
            className="fb-dl-export-btn"
          >
            üìÑ Export JSON
          </button>
          <button
            onClick={exportToCSV}
            disabled={selected.size === 0}
            className="fb-dl-export-btn"
          >
            üìä Export CSV
          </button>
        </div>

        <div className="fb-dl-posts">
          {posts.length === 0 ? (
            <div className="fb-dl-empty">
              No posts detected yet. Scroll through Facebook to capture posts.
            </div>
          ) : (
            <table className="fb-dl-table">
              <thead>
                <tr>
                  <th style={{ width: "40px" }}>Select</th>
                  <th>Author</th>
                  <th>Date</th>
                  {timeFilter && <th style={{ width: "120px" }}>Age</th>}
                  <th>Media</th>
                  <th>Text Preview</th>
                </tr>
              </thead>
              <tbody>
                {posts.map((post) => {
                  const timeProgress = getTimeProgress(post.createdTime);

                  return (
                    <tr
                      key={post.id}
                      className={selected.has(post.id) ? "selected" : ""}
                    >
                      <td>
                        <input
                          type="checkbox"
                          checked={selected.has(post.id)}
                          onChange={() => togglePost(post.id)}
                          disabled={downloading}
                        />
                      </td>
                      <td>{post.author || "Unknown"}</td>
                      <td>{formatDate(post.createdTime)}</td>
                      {timeFilter && (
                        <td>
                          {timeProgress ? (
                            <div
                              style={{
                                display: "flex",
                                flexDirection: "column",
                                gap: "4px",
                              }}
                            >
                              <small
                                style={{ fontSize: "11px", fontWeight: "bold" }}
                              >
                                {timeProgress.ageText}
                              </small>
                              <div
                                style={{
                                  width: "100%",
                                  height: "6px",
                                  backgroundColor: "#e0e0e0",
                                  borderRadius: "3px",
                                  overflow: "hidden",
                                }}
                              >
                                <div
                                  style={{
                                    width: `${timeProgress.percentage}%`,
                                    height: "100%",
                                    backgroundColor:
                                      timeProgress.percentage > 80
                                        ? "#28a745"
                                        : timeProgress.percentage > 50
                                        ? "#ffc107"
                                        : "#dc3545",
                                    transition: "width 0.3s ease",
                                  }}
                                />
                              </div>
                            </div>
                          ) : (
                            <small>-</small>
                          )}
                        </td>
                      )}
                      <td>
                        {post.media?.length || 0}
                        {post.media?.length > 0 && (
                          <span className="fb-dl-media-types">
                            (
                            {post.media
                              .map((m) => (m.type === "video" ? "üé•" : "üñºÔ∏è"))
                              .join("")}
                            )
                          </span>
                        )}
                      </td>
                      <td className="fb-dl-text-preview">
                        {post.text.substring(0, 50) +
                          (post.text.length > 50 ? "..." : "")}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          )}
        </div>
      </div>
    </div>
  );
}


===== ./injected\graphql-interceptor.js =====

// ENHANCED DIAGNOSTIC VERSION - Comprehensive logging
console.log("[FB Downloader] üî¨ ENHANCED DIAGNOSTIC VERSION LOADING...");

const detectedPosts = new Map();
let requestCount = 0;

/**
 * Parse NDJSON response text into array of objects.
 */
function parseNdjson(text) {
  // Strip common anti-JSON prefixes
  if (text.startsWith("for (;;);")) text = text.slice("for (;;);".length);
  if (text.startsWith(")]}'")) {
    const firstNewline = text.indexOf("\n");
    text = firstNewline === -1 ? "" : text.slice(firstNewline + 1);
  }

  const result = [];
  for (const line of text.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    try {
      result.push(JSON.parse(trimmed));
    } catch {
      // skip invalid JSON lines
    }
  }
  return result;
}

// Fetch interceptor
if (!window.__fbDownloaderFetchPatched) {
  window.__fbDownloaderFetchPatched = true;
  console.log("[FB Downloader] üîß Patching fetch...");

  const originalFetch = window.fetch;

  window.fetch = async function patchedFetch(input, init = {}) {
    try {
      const url =
        typeof input === "string"
          ? input
          : input instanceof Request
          ? input.url
          : input instanceof URL
          ? input.href
          : undefined;

      if (
        init?.method === "POST" &&
        typeof url === "string" &&
        url.includes("/api/graphql")
      ) {
        requestCount++;
        console.log(
          `[FB Downloader] üì° GraphQL Request #${requestCount}: ${url}`
        );

        const res = await originalFetch(input, init);
        const clone = res.clone();
        const text = await clone.text();

        console.log(`[FB Downloader] üì¶ Response size: ${text.length} bytes`);

        const responseBody = parseNdjson(text);
        console.log(
          `[FB Downloader] üìã Parsed ${responseBody.length} JSON objects`
        );

        // LOG THE ENTIRE RESPONSE (first 2 items only to save space)
        console.log(
          `[FB Downloader] üîç FULL RESPONSE (first 2 items):`,
          JSON.parse(JSON.stringify(responseBody.slice(0, 2)))
        );

        extractPostsFromGraphQL(responseBody, requestCount);

        return res;
      }
    } catch (err) {
      console.error("[FB Downloader] ‚ùå Fetch error:", err);
    }

    return originalFetch(input, init);
  };
}

// XHR interceptor
if (!window.__fbDownloaderXHRPatched) {
  window.__fbDownloaderXHRPatched = true;
  console.log("[FB Downloader] üîß Patching XMLHttpRequest...");

  const originalXHROpen = XMLHttpRequest.prototype.open;
  const originalXHRSend = XMLHttpRequest.prototype.send;

  XMLHttpRequest.prototype.open = function (method, url, ...args) {
    this._fbdl_url = url;
    this._fbdl_method = method;
    return originalXHROpen.call(this, method, url, ...args);
  };

  XMLHttpRequest.prototype.send = function (body) {
    if (this._fbdl_url && this._fbdl_url.includes("/api/graphql")) {
      this.addEventListener("load", function () {
        try {
          requestCount++;
          console.log(
            `[FB Downloader] üì° XHR GraphQL Request #${requestCount}`
          );

          const responseBody = parseNdjson(this.responseText);
          console.log(
            `[FB Downloader] üìã Parsed ${responseBody.length} JSON objects`
          );

          extractPostsFromGraphQL(responseBody, requestCount);
        } catch (e) {
          console.error("[FB Downloader] ‚ùå XHR error:", e);
        }
      });
    }
    return originalXHRSend.call(this, body);
  };
}

function extractPostsFromGraphQL(responseBody, reqNum) {
  try {
    console.log(`[FB Downloader] üîç Processing request #${reqNum}...`);

    // Search for ANY object with text content
    const objectsWithText = findObjectsWithText(responseBody);
    console.log(
      `[FB Downloader] üí¨ Found ${objectsWithText.length} objects with text content`
    );

    if (objectsWithText.length > 0) {
      console.log(
        `[FB Downloader] üìù Text samples:`,
        objectsWithText.slice(0, 5).map((obj) => {
          const getText = (val) => {
            if (typeof val === "string") return val.substring(0, 50);
            if (val?.text && typeof val.text === "string")
              return val.text.substring(0, 50);
            return "(complex object)";
          };
          return {
            id: obj.id,
            hasId: obj.hasId,
            text: getText(obj.text || obj.message || obj.body),
          };
        })
      );
    }

    const posts = findPosts(responseBody);
    console.log(
      `[FB Downloader] üéØ Found ${posts.length} potential posts in request #${reqNum}`
    );

    let newPostsCount = 0;

    posts.forEach((post, index) => {
      if (post.id && !detectedPosts.has(post.id)) {
        const parsedPost = parsePost(post);

        // Skip posts with no text content
        if (!parsedPost.text || parsedPost.text.trim().length === 0) {
          console.log(
            `[FB Downloader] ‚è≠Ô∏è Skipped post (no text): ${parsedPost.id.substring(
              0,
              20
            )}`
          );
          return;
        }

        console.log(`[FB Downloader] üìÑ Post #${index + 1}/${posts.length}:`, {
          id: parsedPost.id.substring(0, 20) + "...",
          author: parsedPost.author,
          mediaCount: parsedPost.media?.length || 0,
          hasText: !!parsedPost.text,
          textPreview: parsedPost.text?.substring(0, 40) || "(none)",
          __typename: post.__typename || "(not set)",
        });

        // Log media details for posts with media
        if (parsedPost.media && parsedPost.media.length > 0) {
          console.log(
            `[FB Downloader] üñºÔ∏è Media in post ${parsedPost.id.substring(
              0,
              20
            )}:`,
            parsedPost.media.map((m) => ({
              type: m.type,
              url: m.url.substring(0, 60) + "...",
            }))
          );
        }

        detectedPosts.set(post.id, parsedPost);
        newPostsCount++;
      }
    });

    console.log(
      `[FB Downloader] ‚úÖ Added ${newPostsCount} new posts. Total: ${detectedPosts.size}`
    );

    // Show detailed breakdown
    const allPosts = Array.from(detectedPosts.values());
    const withMedia = allPosts.filter((p) => p.media?.length > 0).length;
    const withText = allPosts.filter((p) => p.text).length;
    const textOnly = allPosts.filter((p) => !p.media?.length && p.text).length;
    const mediaOnly = allPosts.filter((p) => p.media?.length && !p.text).length;

    console.log(
      `[FB Downloader] üìä BREAKDOWN: Total=${allPosts.length} | WithMedia=${withMedia} | WithText=${withText} | TextOnly=${textOnly} | MediaOnly=${mediaOnly}`
    );

    if (newPostsCount > 0) {
      notifyPosts();
    }
  } catch (e) {
    console.error("[FB Downloader] ‚ùå Extract error:", e, e.stack);
  }
}

// Find ANY object that has text content
function findObjectsWithText(obj, results = [], depth = 0) {
  if (!obj || typeof obj !== "object" || depth > 20) return results;

  if (obj.message || obj.text || obj.body) {
    results.push({
      id: obj.id || "(no-id)",
      message: obj.message,
      text: obj.text,
      body: obj.body,
      hasId: !!obj.id,
    });
  }

  if (Array.isArray(obj)) {
    obj.forEach((item) => findObjectsWithText(item, results, depth + 1));
  } else {
    Object.values(obj).forEach((value) => {
      if (value && typeof value === "object") {
        findObjectsWithText(value, results, depth + 1);
      }
    });
  }

  return results;
}

// Check if an object is a comment (not a post)
function isComment(obj) {
  if (!obj) return false;

  // Comments have __typename "Comment"
  if (obj.__typename === "Comment") return true;

  // Comments often have a "comment" field or are nested under "comment"
  if (obj.comment) return true;

  // Comments might have "parent_feedback" indicating they're replies
  if (obj.parent_feedback) return true;

  // Comments often have "feedback" with "comment_count" but no "share_count"
  // Posts typically have both or neither
  if (
    obj.feedback &&
    obj.feedback.comment_count &&
    !obj.feedback.share_count &&
    !obj.feedback.reactors
  ) {
    return true;
  }

  // If it has a very short ID (comments often have shorter IDs than posts)
  // This is a weak signal, so use carefully
  if (obj.id && typeof obj.id === "string" && obj.id.length < 10) {
    return true;
  }

  return false;
}

// Check if an object is a shared post (not an original post)
function isSharedPost(obj) {
  if (!obj) return false;

  // Shared posts often have a "reshare" or "share" field
  if (obj.reshare || obj.share) return true;

  // Shared posts might have __typename "SharedStory"
  if (obj.__typename === "SharedStory") return true;

  // Shared posts often have "attached_story" which is the original post
  if (obj.attached_story && obj.attached_story !== obj) return true;

  return false;
}

// Recursively find post objects
function findPosts(obj, posts = [], depth = 0) {
  if (!obj || typeof obj !== "object" || depth > 20) return posts;

  // Check wrappers first (common in Facebook GraphQL)
  if (
    obj.node?.id &&
    obj.node &&
    !isComment(obj.node) &&
    !isSharedPost(obj.node)
  ) {
    posts.push(obj.node);
  }

  if (
    obj.story?.id &&
    obj.story &&
    !isComment(obj.story) &&
    !isSharedPost(obj.story)
  ) {
    posts.push(obj.story);
  }

  if (
    obj.edge?.node?.id &&
    obj.edge.node &&
    !isComment(obj.edge.node) &&
    !isSharedPost(obj.edge.node)
  ) {
    posts.push(obj.edge.node);
  }

  // Capture if it has ID AND any content indicators AND is not a comment or shared post
  if (
    obj.id &&
    typeof obj.id === "string" &&
    !isComment(obj) &&
    !isSharedPost(obj)
  ) {
    const hasContent = !!(
      obj.message ||
      obj.text ||
      obj.body ||
      obj.attachments ||
      obj.media ||
      obj.comet_sections ||
      obj.attached_story
    );

    if (hasContent) {
      posts.push(obj);
    }
  }

  // Recurse through arrays and objects
  if (Array.isArray(obj)) {
    obj.forEach((item) => findPosts(item, posts, depth + 1));
  } else {
    Object.values(obj).forEach((value) => {
      if (value && typeof value === "object") {
        findPosts(value, posts, depth + 1);
      }
    });
  }

  return posts;
}

// Parse post object to extract relevant data
function parsePost(post) {
  return {
    id: post.id || generateId(),
    author: extractAuthor(post),
    createdTime: extractCreatedTime(post),
    text: extractText(post),
    group: extractGroup(post),
    media: extractMedia(post),
  };
}

// Extract author information
function extractAuthor(post) {
  const paths = [
    post.from?.name,
    post.actors?.[0]?.name,
    post.owner?.name,
    post.author?.name,
    post.author,
    post.comet_sections?.content?.story?.actors?.[0]?.name,
    post.node?.actors?.[0]?.name,
    post.story?.actors?.[0]?.name,
  ];

  for (const path of paths) {
    if (path && typeof path === "string") return path;
  }
  return "Unknown";
}

// Extract creation time
function extractCreatedTime(post) {
  const paths = [
    post.created_time,
    post.creation_time,
    post.publish_time,
    post.timestamp,
    post.comet_sections?.content?.story?.creation_time,
    post.node?.creation_time,
  ];

  for (const path of paths) {
    if (path) return typeof path === "number" ? path : parseInt(path);
  }
  return Math.floor(Date.now() / 1000);
}

// Extract text content
function extractText(post) {
  const paths = [
    post.message?.text,
    post.message,
    post.text,
    post.body,
    post.comet_sections?.content?.story?.message?.text,
    post.story_message?.text,
    post.node?.message?.text,
    post.node?.message,
    post.story?.message?.text,
    post.story?.message,
  ];

  for (const path of paths) {
    if (path && typeof path === "string" && path.trim().length > 0) {
      return path.trim();
    }
  }
  return null;
}

// Extract group information
function extractGroup(post) {
  const paths = [
    post.to?.data?.[0]?.name,
    post.to?.name,
    post.group?.name,
    post.feedback?.owning_group?.name,
  ];

  for (const path of paths) {
    if (path && typeof path === "string") return path;
  }
  return null;
}

// Extract media URLs from attachments
function extractMedia(post) {
  const media = [];

  function searchMedia(obj, depth = 0) {
    if (!obj || typeof obj !== "object" || depth > 12) return;

    // Image URLs
    if (obj.image?.uri) media.push({ type: "image", url: obj.image.uri });
    if (obj.image?.url) media.push({ type: "image", url: obj.image.url });
    if (obj.photo?.image?.uri)
      media.push({ type: "image", url: obj.photo.image.uri });
    if (obj.full_width?.uri)
      media.push({ type: "image", url: obj.full_width.uri });
    if (obj.large_image?.uri)
      media.push({ type: "image", url: obj.large_image.uri });

    // Video URLs
    if (obj.video?.playable_url)
      media.push({ type: "video", url: obj.video.playable_url });
    if (obj.playable_url) media.push({ type: "video", url: obj.playable_url });
    if (obj.playable_url_quality_hd)
      media.push({ type: "video", url: obj.playable_url_quality_hd });
    if (obj.browser_native_hd_url)
      media.push({ type: "video", url: obj.browser_native_hd_url });
    if (obj.browser_native_sd_url)
      media.push({ type: "video", url: obj.browser_native_sd_url });

    // Generic URL that might be an image
    if (
      obj.url &&
      typeof obj.url === "string" &&
      (obj.url.includes("fbcdn.net") || obj.url.includes("facebook.com/photo"))
    ) {
      media.push({ type: "image", url: obj.url });
    }

    // Recursively search
    if (Array.isArray(obj)) {
      obj.forEach((item) => searchMedia(item, depth + 1));
    } else {
      Object.values(obj).forEach((value) => {
        if (value && typeof value === "object") {
          searchMedia(value, depth + 1);
        }
      });
    }
  }

  searchMedia(post);

  // Remove duplicates
  const uniqueMedia = [];
  const seen = new Set();
  media.forEach((m) => {
    if (!seen.has(m.url)) {
      seen.add(m.url);
      uniqueMedia.push(m);
    }
  });

  return uniqueMedia;
}

// Generate unique ID
function generateId() {
  return `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Notify content script about detected posts
function notifyPosts() {
  const postsArray = Array.from(detectedPosts.values());

  console.log(
    `[FB Downloader] üì¢ Notifying UI of ${postsArray.length} posts (${
      postsArray.filter((p) => p.media?.length).length
    } with media)`
  );

  window.postMessage(
    {
      __EXT__: true,
      type: "POSTS_DETECTED",
      payload: { posts: postsArray },
    },
    "*"
  );
}

// Listen for download requests from UI
window.addEventListener("message", (event) => {
  if (event.source !== window) return;
  const message = event.data;
  if (message && message.__EXT__ === true && message.type === "DOWNLOAD") {
    console.log(
      "[FB Downloader] üì• Download requested for",
      message.payload.posts.length,
      "posts"
    );
    window.postMessage(
      {
        __EXT__: true,
        type: "DOWNLOAD",
        payload: message.payload,
      },
      "*"
    );
  }
});

// Periodically notify UI (keep posts visible)
setInterval(() => {
  if (detectedPosts.size > 0) {
    notifyPosts();
  }
}, 5000);

console.log("[FB Downloader] üî¨ ENHANCED DIAGNOSTIC VERSION READY!");
console.log(
  "[FB Downloader] üìå Now scroll Facebook and watch the console logs"
);
console.log("[FB Downloader] üí° Look for posts with media counts > 0");
