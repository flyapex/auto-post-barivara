

===== ./background\index.js =====

// Background Service Worker

const MAX_CONCURRENT_DOWNLOADS = 3;
const downloadQueue = [];
const activeDownloads = new Map();

// Message handler
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  try {
    if (message.type === "DOWNLOAD") {
      handleDownload(message.payload, sender.tab.id);
      sendResponse({ success: true });
      return true;
    } else if (message.type === "UPDATE_BADGE") {
      updateBadge(message.payload);
      sendResponse({ success: true });
      return true;
    } else if (message.type === "GET_DOWNLOAD_STATUS") {
      sendResponse({
        queue: downloadQueue.length,
        active: activeDownloads.size,
      });
      return true;
    } else if (message.type === "POSTS_DETECTED") {
      sendResponse({ success: true, received: true });
      return true;
    } else {
      sendResponse({ success: true, unknown: true });
      return true;
    }
  } catch (error) {
    console.error("[Background] Error handling message:", error);
    sendResponse({ success: false, error: error.message });
    return true;
  }
});

// Handle download request
async function handleDownload(payload, tabId) {
  const { posts } = payload;

  for (const post of posts) {
    // ALWAYS create metadata file for every post
    const metadata = generateMetadata(post);
    const metadataBlob = new Blob([metadata], { type: "text/markdown" });
    const metadataUrl = URL.createObjectURL(metadataBlob);
    downloadQueue.push({
      url: metadataUrl,
      filename: generateFilename(post, { type: "metadata" }, 0),
      postId: post.id,
      tabId: tabId,
      retries: 0,
      isBlob: true,
    });

    // Download media if post has any
    if (post.media && post.media.length >= 0) {
      for (let i = 0; i < post.media.length; i++) {
        const media = post.media[i];
        const downloadTask = {
          url: media.url,
          filename: generateFilename(post, media, i),
          postId: post.id,
          tabId: tabId,
          retries: 0,
        };
        downloadQueue.push(downloadTask);
      }
    } else {
    }
  }

  processQueue();
}

// Process download queue
async function processQueue() {
  while (
    downloadQueue.length > 0 &&
    activeDownloads.size < MAX_CONCURRENT_DOWNLOADS
  ) {
    const task = downloadQueue.shift();
    startDownload(task);
  }
}

// Start individual download
async function startDownload(task) {
  try {
    const downloadId = await chrome.downloads.download({
      url: task.url,
      filename: task.filename,
      conflictAction: "uniquify",
    });

    activeDownloads.set(downloadId, task);

    // Notify content script
    chrome.tabs
      .sendMessage(task.tabId, {
        type: "DOWNLOAD_STARTED",
        payload: { postId: task.postId, downloadId },
      })
      .catch((err) => {
        console.log(
          "[Background] Could not notify tab (tab may be closed):",
          err.message
        );
      });
  } catch (error) {
    console.error("[Background] Download failed:", error);

    // Retry logic
    if (task.retries < 3) {
      task.retries++;
      downloadQueue.push(task);
      setTimeout(processQueue, 2000);
    } else {
      console.error(
        "[Background] Download failed after 3 retries:",
        task.filename
      );
      // Notify failure
      chrome.tabs
        .sendMessage(task.tabId, {
          type: "DOWNLOAD_FAILED",
          payload: { postId: task.postId, error: error.message },
        })
        .catch(() => {});
    }
  }
}

// Listen for download completion
chrome.downloads.onChanged.addListener((delta) => {
  if (delta.state && delta.state.current === "complete") {
    const task = activeDownloads.get(delta.id);
    if (task) {
      activeDownloads.delete(delta.id);

      // Cleanup blob URLs
      if (task.isBlob) {
        URL.revokeObjectURL(task.url);
      }

      // Notify content script
      chrome.tabs
        .sendMessage(task.tabId, {
          type: "DOWNLOAD_COMPLETE",
          payload: { postId: task.postId, downloadId: delta.id },
        })
        .catch(() => {});

      // Process next in queue
      processQueue();
    }
  } else if (delta.state && delta.state.current === "interrupted") {
    const task = activeDownloads.get(delta.id);
    if (task) {
      console.error("[Background] Download interrupted:", task.filename);
      activeDownloads.delete(delta.id);

      // Retry
      if (task.retries < 3) {
        task.retries++;
        downloadQueue.push(task);
        setTimeout(processQueue, 2000);
      }
    }
  }
});

// Generate safe filename
function generateFilename(post, media, index) {
  const date = post.createdTime
    ? new Date(post.createdTime * 1000)
    : new Date();
  const dateStr = date.toISOString().split("T")[0];
  const author = sanitizeFilename(post.author || "unknown");
  const postIdShort = post.id ? post.id.slice(-8) : "unknown";

  if (media.type === "metadata") {
    return `facebook_downloads/${dateStr}_${author}_${postIdShort}/index.md`;
  }

  const ext = media.type === "video" ? "mp4" : "jpg";
  const suffix = index > 0 ? `_${index}` : "";

  return `facebook_downloads/${dateStr}_${author}_${postIdShort}/${media.type}${suffix}.${ext}`;
}

// Sanitize filename
function sanitizeFilename(str) {
  return str
    .replace(/[^a-z0-9]/gi, "_")
    .replace(/_+/g, "_")
    .substring(0, 50)
    .toLowerCase();
}

// Generate metadata
function generateMetadata(post) {
  let md = `# Facebook Post\n\n`;
  md += `**Post ID:** ${post.id || "N/A"}\n`;
  md += `**Author:** ${post.author || "N/A"}\n`;
  md += `**Created:** ${
    post.createdTime ? new Date(post.createdTime * 1000).toISOString() : "N/A"
  }\n`;
  if (post.group) md += `**Group:** ${post.group}\n`;
  md += `\n## Content\n\n`;
  md += post.text || "(No text content)";
  md += `\n\n## Media\n\n`;
  if (post.media && post.media.length > 0) {
    post.media.forEach((m, i) => {
      md += `- ${m.type} ${i + 1}: ${m.url}\n`;
    });
  } else {
    md += "(No media attachments)\n";
  }
  return md;
}

// Update badge
function updateBadge(count) {
  if (count > 0) {
    chrome.action.setBadgeText({ text: count.toString() });
    chrome.action.setBadgeBackgroundColor({ color: "#4CAF50" });
  } else {
    chrome.action.setBadgeText({ text: "" });
  }
}

// Self-test on startup
setTimeout(() => {
  console.log("[Background] Self-test: Service worker is alive");
}, 1000);


===== ./content\main.jsx =====

import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import DownloaderApp from "./views/DownloaderApp";

// Check if extension context is valid
function isExtensionContextValid() {
  try {
    return !!chrome.runtime?.id;
  } catch (e) {
    return false;
  }
}

// Inject page script
function injectPageScript() {
  if (!isExtensionContextValid()) {
    console.error("[Facebook Downloader] Extension context invalid");
    return;
  }

  try {
    const script = document.createElement("script");
    // Use the new GraphQL interceptor
    script.src = chrome.runtime.getURL("src/injected/graphql-interceptor.js");
    script.type = "module";
    script.onload = () => {
      console.log(
        "[Facebook Downloader] GraphQL interceptor injected successfully"
      );
      script.remove();
    };
    script.onerror = (error) => {
      console.error(
        "[Facebook Downloader] GraphQL interceptor injection failed:",
        error
      );
    };

    const target = document.head || document.documentElement;
    if (target) {
      target.appendChild(script);
    }
  } catch (error) {
    console.error(
      "[Facebook Downloader] Error injecting GraphQL interceptor:",
      error
    );
  }
}

// Message bridge
window.addEventListener("message", (event) => {
  if (event.source !== window) return;

  const message = event.data;

  if (message && message.__EXT__ === true) {
    if (!isExtensionContextValid()) {
      console.error("[Facebook Downloader] ‚ùå Extension context invalid!");
      return;
    }

    chrome.runtime
      .sendMessage({
        type: message.type,
        payload: message.payload,
      })
      .then((response) => {
        if (response) {
          window.postMessage(
            {
              __EXT__: true,
              type: `${message.type}_RESPONSE`,
              payload: response,
            },
            "*"
          );
        }
      })
      .catch((err) => {
        console.error("[Facebook Downloader] Message error:", err.message);
      });
  }
});

// Listen for messages from background
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  window.postMessage(
    {
      __EXT__: true,
      type: message.type,
      payload: message.payload,
    },
    "*"
  );
  sendResponse({ received: true });
  return true;
});

// Create UI
function initializeUI() {
  if (!document.body) {
    setTimeout(initializeUI, 100);
    return;
  }

  if (document.getElementById("fb-downloader-root")) {
    return;
  }

  try {
    const container = document.createElement("div");
    container.id = "fb-downloader-root";
    // CRITICAL: Set attributes to prevent React conflicts
    container.setAttribute("data-reactroot", "");
    container.style.cssText =
      "all: initial; * { all: unset; } position: fixed !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; pointer-events: none !important; z-index: 2147483647 !important;";

    document.body.appendChild(container);

    const root = createRoot(container);

    root.render(<DownloaderApp />);

    setTimeout(() => {
      const check = document.getElementById("fb-downloader-root");

      const button = document.querySelector(".fb-dl-toggle");

      if (button) {
        console.log("[Facebook Downloader] üéâ Button is visible!");
      }
    }, 1000);
  } catch (error) {
    console.error("[Facebook Downloader] ‚ùå Error initializing UI:", error);
  }
}

// Initialize
console.log("[Facebook Downloader] Starting initialization...");

if (!isExtensionContextValid()) {
  console.error("[Facebook Downloader] ‚ùå Extension context invalid!");
} else {
  injectPageScript();

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeUI);
  } else {
    initializeUI();
  }

  setTimeout(() => {
    if (!document.getElementById("fb-downloader-root")) {
      console.log("[Facebook Downloader] Fallback init");
      initializeUI();
    }
  }, 2000);
}

console.log("[Facebook Downloader] Content script END");




===== ./content\views\DownloaderApp.jsx =====

import { useState, useEffect, useRef } from "react";
import "./DownloaderApp.css";

export default function DownloaderApp() {
  const [show, setShow] = useState(false);
  const [posts, setPosts] = useState([]);
  const [selected, setSelected] = useState(new Set());
  const [downloading, setDownloading] = useState(false);
  const [progress, setProgress] = useState({ completed: 0, total: 0 });

  const [isScrolling, setIsScrolling] = useState(false);
  const [scrollStatus, setScrollStatus] = useState("idle");
  const [scrollSpeed, setScrollSpeed] = useState(2000);

  const [timeFilter, setTimeFilter] = useState("");
  const [keywordFilter, setKeywordFilter] = useState(
    "‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ, ‡¶Æ‡¶æ‡¶∂‡¶æ‡¶≤‡ßç‡¶≤‡¶æ‡¶π, ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø, ‡¶ï‡ßá‡¶®‡¶æ, ‡¶∏‡ßá‡¶≤, ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º, ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø, ‡¶¶‡¶æ‡¶Æ, ‡¶¨‡¶æ‡¶∏‡¶æ ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶è‡¶ï‡¶¶‡¶æ‡¶Æ, ‡¶∏‡¶ø‡¶ü ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®, ‡¶¨‡¶æ‡¶∏‡¶æ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®, ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®, ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶æ‡¶®, ‡¶≠‡¶æ‡¶∞‡¶æ ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶≠‡¶æ‡¶∞‡¶æ ‡¶≤‡¶æ‡¶ó‡¶¨, ‡¶≠‡¶æ‡¶°‡¶º‡¶æ ‡¶≤‡¶æ‡¶ó‡¶¨, ‡¶ï‡¶ø‡¶®‡¶§‡ßá, ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º, Sell, welcome, ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶¶‡¶∏‡ßç‡¶Ø, ‡¶Æ‡¶ß‡ßÅ, ‡¶∏‡ßá‡¶≤‡¶æ‡¶∞‡¶ø, Off topic, ‡¶™‡¶æ‡¶∞‡ßç‡¶ü ‡¶ü‡¶æ‡¶á‡¶Æ, ‡¶≠‡¶æ‡¶á‡¶∞‡¶æ‡¶≤_‡¶≠‡¶ø‡¶°‡¶ø‡¶ì, ‡¶∞‡ßÅ‡¶Æ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞, ‡¶¶‡ßÅ‡¶ß, ‡¶Ü‡¶Æ‡¶ø‡¶®, ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞, ‡¶°‡ßá‡¶á‡¶∞‡¶ø ‡¶´‡¶æ‡¶∞‡ßç‡¶Æ, ‡¶°‡ßç‡¶∞‡ßá‡¶∏, youtu.be, ‡¶ì‡¶°‡¶º‡¶®‡¶æ, projon, ‡¶®‡¶ø‡¶Ø‡¶º‡ßã‡¶ó, ‡¶∏‡ßÇ‡¶∞‡¶æ, ‡¶™‡¶°‡¶º‡¶æ‡¶ö‡ßç‡¶õ‡¶ø, ‡¶ï‡ßã‡¶ö‡¶ø‡¶Ç, ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°, ‡¶∂‡ßÅ‡¶≠ ‡¶∞‡¶æ‡¶§‡ßç‡¶∞‡¶ø, ‡¶á‡¶®‡¶ï‡¶æ‡¶Æ, ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º, ‡¶¨‡¶æ‡¶∏‡¶æ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞, ‡¶∏‡ßá‡¶≤, ‡¶°‡ßá‡¶≤‡¶ø‡¶≠‡¶æ‡¶∞‡¶ø, ‡¶∏‡ßã‡¶´‡¶æ ‡¶ï‡ßç‡¶≤‡¶ø‡¶®‡¶ø‡¶Ç,‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ ‡¶™‡ßá‡¶§‡ßá,follow back,ùôÅùô§ùô°ùô°ùô§ùô¨ ùòΩùôñùôòùô†,‡¶¶‡ßã‡¶Ø‡¶º‡¶æ,‡¶ú‡¶æ‡¶§‡ßÄ‡¶Ø‡¶º ‡¶™‡¶æ‡¶ñ‡¶ø,‡¶¶‡ßá‡¶∂‡ßá‡¶∞,room dorkar, bmw,‡¶∏‡¶∞‡¶ï‡¶æ‡¶∞,‡¶Æ‡¶ø‡¶≤‡ßç‡¶ï ‡¶∂‡ßá‡¶ï,‡¶π‡¶æ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá ‡¶ó‡ßá‡¶õ‡ßá,‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶®,‡¶Ü‡¶≤‡ßç‡¶≤‡¶æ‡¶π,‡¶™‡ßç‡¶∞‡¶Æ‡ßã‡¶∂‡¶®‡¶æ‡¶≤ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏‡¶ø‡¶Ç ,Offer,‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶•‡¶æ‡¶ï‡¶ø,‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá,Rent a car, RAM ‡¶Ø‡ßÅ‡¶¶‡ßç‡¶ß,‡¶à‡¶¶‡ßá‡¶∞,Page,‡¶Æ‡ßá‡¶π‡ßá‡¶¶‡ßÄ,‡¶ï‡ßç‡¶∞‡¶ø‡¶Æ,with a Facebook Post:, Sale, mAh ,‡¶¨‡ßá‡¶§‡¶® ,teacher,‡¶™‡¶æ‡¶á‡¶ï‡¶æ‡¶∞‡¶ø, ‡¶™‡ßç‡¶∞‡¶æ‡¶ï‡¶ü‡¶ø‡¶ï‡¶æ‡¶≤"
  );
  const [numberFilter, setNumberFilter] = useState(true);

  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [isInitialized, setIsInitialized] = useState(false);

  const scrollIntervalRef = useRef(null);
  const panelRef = useRef(null);

  useEffect(() => {
    if (show && !isInitialized && panelRef.current) {
      setTimeout(() => {
        const panel = panelRef.current;
        if (!panel) return;

        const rect = panel.getBoundingClientRect();

        setPosition({
          x: Math.max(0, (window.innerWidth - rect.width) / 2),
          y: Math.max(0, (window.innerHeight - rect.height) / 2),
        });
        setIsInitialized(true);
      }, 0);
    }
  }, [show, isInitialized]);

  const parseTimeFilter = (filterStr) => {
    if (!filterStr || filterStr.trim() === "") return null;

    const match = filterStr.match(/^(\d+)([smhd])$/i);
    if (!match) return null;

    const value = parseInt(match[1]);
    const unit = match[2].toLowerCase();

    const multipliers = {
      s: 1,
      m: 60,
      h: 3600,
      d: 86400,
    };

    return value * (multipliers[unit] || 0);
  };

  const passesTimeFilter = (post) => {
    const filterSeconds = parseTimeFilter(timeFilter);
    if (!filterSeconds) return true;

    const postTime = post.createdTime;
    if (!postTime) return false;

    const now = Math.floor(Date.now() / 1000);
    const ageSeconds = now - postTime;

    if (ageSeconds < 0 || ageSeconds > 60 * 60 * 24 * 365) return false;

    return ageSeconds <= filterSeconds;
  };

  const passesKeywordFilter = (post) => {
    if (!keywordFilter.trim()) return true;

    const keywords = keywordFilter
      .split(",")
      .map((k) => k.trim().toLowerCase())
      .filter((k) => k.length > 0);

    if (keywords.length === 0) return true;

    const postText = (post.text || "").toLowerCase();

    return !keywords.some((keyword) => postText.includes(keyword));
  };

  const passesNumberFilter = (post) => {
    if (!numberFilter) return true;

    const text = post.text || "";
    if (typeof text !== "string") return true;

    const cleanedText = text.replace(/[- ]/g, "");

    const numberPattern = /01\d{7,10}/g;
    const matches = cleanedText.match(numberPattern);

    return !matches || matches.length === 0;
  };

  const filterPosts = (postsArray) => {
    // console.log("Filtering posts with current filters...");
    // console.log("Time Filter:", postsArray);
    return postsArray.filter((post) => {
      if (!post.text || post.text.trim().length === 0) return false;

      if (!passesTimeFilter(post)) {
        return false;
      }

      if (!passesKeywordFilter(post)) {
        return false;
      }

      if (!passesNumberFilter(post)) {
        return false;
      }

      return true;
    });
  };

  useEffect(() => {
    const handleMessage = (event) => {
      if (event.source !== window) return;
      const message = event.data;

      if (message && message.__EXT__ === true) {
        switch (message.type) {
          case "POSTS_DETECTED":
            const filteredPosts = filterPosts(message.payload.posts);
            setPosts(filteredPosts);
            break;
          case "DOWNLOAD_STARTED":
            setDownloading(true);
            break;
          case "DOWNLOAD_COMPLETE":
            setProgress((prev) => ({ ...prev, completed: prev.completed + 1 }));
            break;
          case "DOWNLOAD_FAILED":
            console.error("Download failed:", message.payload);
            break;
          case "ALL_DOWNLOADS_COMPLETE":
            setDownloading(false);
            setProgress({ completed: 0, total: 0 });
            setSelected(new Set());
            break;
          case "EXTENSION_INVALIDATED":
            alert(
              message.payload.message +
                "\n\nPress Ctrl+R (or Cmd+R on Mac) to refresh."
            );
            break;
        }
      }
    };

    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, [timeFilter, keywordFilter, numberFilter]);

  useEffect(() => {
    const handleMouseMove = (e) => {
      if (!isDragging) return;

      setPosition({
        x: e.clientX - dragOffset.x,
        y: e.clientY - dragOffset.y,
      });
    };

    const handleMouseUp = () => {
      setIsDragging(false);
    };

    if (isDragging) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    }

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [isDragging, dragOffset]);

  const handleMouseDown = (e) => {
    const target = e.target;
    if (!target.closest(".fb-dl-header")) return;
    if (target.tagName === "BUTTON" || target.tagName === "INPUT") return;

    const panel = panelRef.current;
    if (!panel) return;

    const rect = panel.getBoundingClientRect();
    setDragOffset({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    });
    setIsDragging(true);
    e.preventDefault();
  };

  const startAutoScroll = () => {
    setScrollStatus("running");
    setIsScrolling(true);

    scrollIntervalRef.current = setInterval(() => {
      window.scrollBy({
        top: scrollSpeed,
        behavior: "smooth",
      });

      if (
        window.innerHeight + window.scrollY >=
        document.body.offsetHeight - 100
      ) {
        pauseAutoScroll();
      }
    }, 2000);
  };

  const pauseAutoScroll = () => {
    if (scrollIntervalRef.current) {
      clearInterval(scrollIntervalRef.current);
      scrollIntervalRef.current = null;
    }
    setScrollStatus("paused");
    setIsScrolling(false);
  };

  const stopAutoScroll = () => {
    if (scrollIntervalRef.current) {
      clearInterval(scrollIntervalRef.current);
      scrollIntervalRef.current = null;
    }
    setScrollStatus("stopped");
    setIsScrolling(false);
  };

  const clearAllPosts = () => {
    if (window.confirm("Are you sure you want to clear all detected posts?")) {
      setPosts([]);
      setSelected(new Set());
    }
  };

  const togglePost = (postId) => {
    setSelected((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(postId)) {
        newSet.delete(postId);
      } else {
        newSet.add(postId);
      }
      return newSet;
    });
  };

  const selectAll = () => {
    if (selected.size === posts.length) {
      setSelected(new Set());
    } else {
      setSelected(new Set(posts.map((p) => p.id)));
    }
  };

  const handleDownload = () => {
    const selectedPosts = posts.filter((p) => selected.has(p.id));
    if (selectedPosts.length === 0) return;

    const totalMedia = selectedPosts.reduce(
      (acc, p) => acc + (p.media?.length || 0),
      0
    );
    setProgress({ completed: 0, total: totalMedia });

    window.postMessage(
      {
        __EXT__: true,
        type: "DOWNLOAD",
        payload: { posts: selectedPosts },
      },
      "*"
    );
  };

  const exportToJSON = () => {
    const selectedPosts = posts.filter((p) => selected.has(p.id));
    const dataStr = JSON.stringify(selectedPosts, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `facebook_posts_${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const exportToCSV = () => {
    const selectedPosts = posts.filter((p) => selected.has(p.id));

    let csv = "ID,Author,Date,Text,Media Count,Media Types,Media URLs\n";

    selectedPosts.forEach((post) => {
      const date = post.createdTime
        ? new Date(post.createdTime * 1000).toISOString()
        : "Unknown";
      const text = (post.text || "").replace(/"/g, '""').replace(/\n/g, " ");
      const mediaCount = post.media?.length || 0;
      const mediaTypes = post.media?.map((m) => m.type).join("; ") || "";
      const mediaUrls = post.media?.map((m) => m.url).join("; ") || "";

      csv += `"${post.id}","${
        post.author || ""
      }","${date}","${text}",${mediaCount},"${mediaTypes}","${mediaUrls}"\n`;
    });

    const dataBlob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `facebook_posts_${Date.now()}.csv`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const formatTime = (timestamp, type = "full") => {
    if (!timestamp) return "Unknown";

    const date = new Date(timestamp * 1000);

    if (type === "full") {
      return date.toLocaleDateString() + " " + date.toLocaleTimeString();
    }

    const now = Math.floor(Date.now() / 1000);
    const secondsAgo = now - timestamp;

    if (secondsAgo < 60) return `${Math.floor(secondsAgo)}s ago`;
    if (secondsAgo < 3600) return `${Math.floor(secondsAgo / 60)}m ago`;
    if (secondsAgo < 86400) return `${Math.floor(secondsAgo / 3600)}h ago`;
    return `${Math.floor(secondsAgo / 86400)}d ago`;
  };

  const getTimeProgress = (timestamp) => {
    const filterSeconds = parseTimeFilter(timeFilter);
    const postTime = timestamp;
    if (!filterSeconds || !postTime) return null;

    const now = Math.floor(Date.now() / 1000);
    const postAge = now - postTime;

    const percentage = Math.max(0, 100 - (postAge / filterSeconds) * 100);

    return {
      percentage,
      age: postAge,
      ageText: formatTime(timestamp, "relative"),
    };
  };

  if (!show) {
    return (
      <div className="fb-dl-toggle" style={{ pointerEvents: "auto" }}>
        <button className="fb-dl-toggle-btn" onClick={() => setShow(true)}>
          üì• {posts.length > 0 && `(${posts.length})`}
        </button>
      </div>
    );
  }

  return (
    <div
      className="fb-dl-container"
      style={{
        pointerEvents: "auto",
        position: "fixed",
        left: isInitialized ? `${position.x}px` : "50%",
        top: isInitialized ? `${position.y}px` : "50%",
        transform: isInitialized ? "none" : "translate(-50%, -50%)",
        right: "auto",
        bottom: "auto",
      }}
    >
      <div
        className="fb-dl-panel"
        ref={panelRef}
        onMouseDown={handleMouseDown}
        style={{ cursor: isDragging ? "grabbing" : "default" }}
      >
        <div
          className="fb-dl-header"
          style={{ cursor: "grab", userSelect: "none" }}
        >
          <h2 style={{ margin: 0, fontSize: "18px" }}>
            Facebook Post Downloader
          </h2>
          <button className="fb-dl-close" onClick={() => setShow(false)}>
            ‚úï
          </button>
        </div>

        <div className="fb-dl-autoscroll">
          <div className="fb-dl-section-title">üîÑ Auto-Scroll</div>
          <div className="fb-dl-scroll-controls">
            <button
              onClick={startAutoScroll}
              disabled={isScrolling || scrollStatus === "running"}
              className="fb-dl-btn-start"
            >
              ‚ñ∂Ô∏è Start
            </button>
            <button
              onClick={pauseAutoScroll}
              disabled={!isScrolling}
              className="fb-dl-btn-pause"
            >
              ‚è∏Ô∏è Pause
            </button>
            <button
              onClick={stopAutoScroll}
              disabled={scrollStatus === "idle"}
              className="fb-dl-btn-stop"
            >
              ‚èπÔ∏è Stop
            </button>
            <span className="fb-dl-scroll-status">
              Status: <strong>{scrollStatus}</strong>
            </span>
          </div>
          <div
            style={{
              marginTop: "8px",
              display: "flex",
              alignItems: "center",
              gap: "8px",
            }}
          >
            <label
              style={{ display: "flex", alignItems: "center", gap: "5px" }}
            >
              Speed:
              <input
                type="number"
                value={scrollSpeed}
                onChange={(e) =>
                  setScrollSpeed(
                    Math.max(100, parseInt(e.target.value) || 2000)
                  )
                }
                style={{ width: "70px" }}
                min="100"
                max="5000"
                step="100"
              />
              px
            </label>
          </div>
        </div>

        <div className="fb-dl-filters">
          <div className="fb-dl-section-title">üîç Filters</div>

          <div className="fb-dl-filter-row">
            <label>
              Time Filter:
              <input
                type="text"
                value={timeFilter}
                onChange={(e) => setTimeFilter(e.target.value)}
                placeholder="e.g., 10m, 2h, 1d"
                style={{ width: "100px", marginLeft: "5px" }}
              />
            </label>
            <small style={{ marginLeft: "10px", color: "#666" }}>
              (m=minutes, h=hours, d=days)
            </small>
          </div>

          <div className="fb-dl-filter-row">
            <label style={{ display: "block", marginBottom: "5px" }}>
              Keyword Filter (comma-separated):
            </label>
            <textarea
              value={keywordFilter}
              onChange={(e) => setKeywordFilter(e.target.value)}
              rows="3"
              style={{ width: "100%", fontSize: "12px" }}
              placeholder="Posts containing these keywords will be filtered out"
            />
          </div>

          <div className="fb-dl-filter-row">
            <label
              style={{ display: "flex", alignItems: "center", gap: "8px" }}
            >
              <input
                type="checkbox"
                checked={numberFilter}
                onChange={(e) => setNumberFilter(e.target.checked)}
              />
              Filter out posts with phone numbers (01XXXXXXXXX)
            </label>
          </div>
        </div>

        <div className="fb-dl-stats">
          <span>Total posts: {posts.length}</span>
          <span>Selected: {selected.size}</span>
        </div>

        {downloading && (
          <div className="fb-dl-progress">
            <div className="fb-dl-progress-bar">
              <div
                className="fb-dl-progress-fill"
                style={{
                  width: `${(progress.completed / progress.total) * 100}%`,
                }}
              />
            </div>
            <span>
              {progress.completed} / {progress.total} files
            </span>
          </div>
        )}

        <div className="fb-dl-controls">
          <button onClick={selectAll} disabled={downloading}>
            {selected.size === posts.length ? "Deselect All" : "Select All"}
          </button>
          <button
            onClick={clearAllPosts}
            disabled={downloading || posts.length === 0}
            className="fb-dl-clear-btn"
            style={{ backgroundColor: "#dc3545" }}
          >
            üóëÔ∏è Clear All
          </button>
          <button
            onClick={handleDownload}
            disabled={selected.size === 0 || downloading}
            className="fb-dl-download-btn"
          >
            üì• Download Media ({selected.size})
          </button>
          <button
            onClick={exportToJSON}
            disabled={selected.size === 0}
            className="fb-dl-export-btn"
          >
            üìÑ Export JSON
          </button>
          <button
            onClick={exportToCSV}
            disabled={selected.size === 0}
            className="fb-dl-export-btn"
          >
            üìä Export CSV
          </button>
        </div>

        <div className="fb-dl-posts">
          {posts.length === 0 ? (
            <div className="fb-dl-empty">
              No posts detected yet. Scroll through Facebook to capture posts.
            </div>
          ) : (
            <table className="fb-dl-table">
              <thead>
                <tr>
                  <th style={{ width: "40px" }}>Select</th>
                  <th>Author</th>
                  <th>Date</th>
                  {timeFilter && <th style={{ width: "120px" }}>Age</th>}
                  <th>Media</th>
                  <th>Text Preview</th>
                </tr>
              </thead>
              <tbody>
                {posts.map((post) => {
                  const timeProgress = getTimeProgress(post.createdTime);

                  return (
                    <tr
                      key={post.id}
                      className={selected.has(post.id) ? "selected" : ""}
                    >
                      <td>
                        <input
                          type="checkbox"
                          checked={selected.has(post.id)}
                          onChange={() => togglePost(post.id)}
                          disabled={downloading}
                        />
                      </td>
                      <td>{post.author || "Unknown"}</td>
                      <td>
                        <div style={{ fontSize: "12px" }}>
                          <div>{formatTime(post.createdTime, "full")}</div>
                          <div
                            style={{
                              color: "#666",
                              fontSize: "11px",
                              marginTop: "2px",
                            }}
                          >
                            {formatTime(post.createdTime, "relative")}
                          </div>
                        </div>
                      </td>
                      {timeFilter && (
                        <td>
                          {timeProgress ? (
                            <div
                              style={{
                                display: "flex",
                                flexDirection: "column",
                                gap: "4px",
                              }}
                            >
                              <small
                                style={{ fontSize: "11px", fontWeight: "bold" }}
                              >
                                {timeProgress.ageText}
                              </small>
                              <div
                                style={{
                                  width: "100%",
                                  height: "6px",
                                  backgroundColor: "#e0e0e0",
                                  borderRadius: "3px",
                                  overflow: "hidden",
                                }}
                              >
                                <div
                                  style={{
                                    width: `${timeProgress.percentage}%`,
                                    height: "100%",
                                    backgroundColor:
                                      timeProgress.percentage > 80
                                        ? "#28a745"
                                        : timeProgress.percentage > 50
                                        ? "#ffc107"
                                        : "#dc3545",
                                    transition: "width 0.3s ease",
                                  }}
                                />
                              </div>
                            </div>
                          ) : (
                            <small>-</small>
                          )}
                        </td>
                      )}
                      <td>
                        {post.media?.length || 0}
                        {post.media?.length > 0 && (
                          <span className="fb-dl-media-types">
                            (
                            {post.media
                              .map((m) => (m.type === "video" ? "üé•" : "üñºÔ∏è"))
                              .join("")}
                            )
                          </span>
                        )}
                      </td>
                      <td className="fb-dl-text-preview">
                        {post.text.substring(0, 50) +
                          (post.text.length > 50 ? "..." : "")}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          )}
        </div>
      </div>
    </div>
  );
}


===== ./injected\graphql-interceptor.js =====

const detectedPosts = new Map();

function parseNdjson(text) {
  if (text.startsWith("for (;;);")) text = text.slice("for (;;);".length);
  if (text.startsWith(")]}'")) {
    const firstNewline = text.indexOf("\n");
    text = firstNewline === -1 ? "" : text.slice(firstNewline + 1);
  }

  const result = [];
  for (const line of text.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    try {
      result.push(JSON.parse(trimmed));
    } catch {
      continue;
    }
  }
  return result;
}

if (!window.__fbDownloaderFetchPatched) {
  window.__fbDownloaderFetchPatched = true;

  const originalFetch = window.fetch;

  window.fetch = async function patchedFetch(input, init = {}) {
    try {
      const url =
        typeof input === "string"
          ? input
          : input instanceof Request
          ? input.url
          : input instanceof URL
          ? input.href
          : undefined;

      if (
        init?.method === "POST" &&
        typeof url === "string" &&
        url.includes("/api/graphql")
      ) {
        const res = await originalFetch(input, init);
        const clone = res.clone();
        const text = await clone.text();
        const responseBody = parseNdjson(text);

        extractPostsFromGraphQL(responseBody);

        return res;
      }
    } catch (err) {
      // Silent error handling
    }

    return originalFetch(input, init);
  };
}

if (!window.__fbDownloaderXHRPatched) {
  window.__fbDownloaderXHRPatched = true;

  const originalXHROpen = XMLHttpRequest.prototype.open;
  const originalXHRSend = XMLHttpRequest.prototype.send;

  XMLHttpRequest.prototype.open = function (method, url, ...args) {
    this._fbdl_url = url;
    this._fbdl_method = method;
    return originalXHROpen.call(this, method, url, ...args);
  };

  XMLHttpRequest.prototype.send = function (body) {
    if (this._fbdl_url && this._fbdl_url.includes("/api/graphql")) {
      this.addEventListener("load", function () {
        try {
          const responseBody = parseNdjson(this.responseText);
          extractPostsFromGraphQL(responseBody);
        } catch (e) {
          // Silent error handling
        }
      });
    }
    return originalXHRSend.call(this, body);
  };
}

function extractPostsFromGraphQL(responseBody) {
  try {
    const posts = findPosts(responseBody);
    let newPostsCount = 0;

    posts.forEach((post) => {
      if (post.id && !detectedPosts.has(post.id)) {
        const parsedPost = parsePost(post);

        if (!parsedPost.text || parsedPost.text.trim().length === 0) {
          return;
        }

        detectedPosts.set(post.id, parsedPost);
        newPostsCount++;
      }
    });

    if (newPostsCount > 0) {
      notifyPosts();
    }
  } catch (e) {
    // Silent error handling
  }
}

function isComment(obj) {
  if (!obj) return false;

  if (obj.__typename === "Comment") return true;
  if (obj.comment) return true;
  if (obj.parent_feedback) return true;

  if (
    obj.feedback &&
    obj.feedback.comment_count &&
    !obj.feedback.share_count &&
    !obj.feedback.reactors
  ) {
    return true;
  }

  if (obj.id && typeof obj.id === "string" && obj.id.length < 10) {
    return true;
  }

  return false;
}

function isSharedPost(obj) {
  if (!obj) return false;

  if (obj.reshare || obj.share) return true;
  if (obj.__typename === "SharedStory") return true;
  if (obj.attached_story && obj.attached_story !== obj) return true;

  return false;
}

function findPosts(obj, posts = [], depth = 0) {
  if (!obj || typeof obj !== "object" || depth > 20) return posts;

  if (
    obj.node?.id &&
    obj.node &&
    !isComment(obj.node) &&
    !isSharedPost(obj.node)
  ) {
    posts.push(obj.node);
  }

  if (
    obj.story?.id &&
    obj.story &&
    !isComment(obj.story) &&
    !isSharedPost(obj.story)
  ) {
    posts.push(obj.story);
  }

  if (
    obj.edge?.node?.id &&
    obj.edge.node &&
    !isComment(obj.edge.node) &&
    !isSharedPost(obj.edge.node)
  ) {
    posts.push(obj.edge.node);
  }

  if (
    obj.id &&
    typeof obj.id === "string" &&
    !isComment(obj) &&
    !isSharedPost(obj)
  ) {
    const hasContent = !!(
      obj.message ||
      obj.text ||
      obj.body ||
      obj.attachments ||
      obj.media ||
      obj.comet_sections ||
      obj.attached_story
    );

    if (hasContent) {
      posts.push(obj);
    }
  }

  if (Array.isArray(obj)) {
    obj.forEach((item) => findPosts(item, posts, depth + 1));
  } else {
    Object.values(obj).forEach((value) => {
      if (value && typeof value === "object") {
        findPosts(value, posts, depth + 1);
      }
    });
  }

  return posts;
}

function parsePost(post) {
  return {
    id: post.id || generateId(),
    author: extractAuthor(post),
    createdTime: extractCreatedTime(post),
    text: extractText(post),
    group: extractGroup(post),
    media: extractMedia(post),
  };
}

function extractAuthor(post) {
  const paths = [
    post.from?.name,
    post.actors?.[0]?.name,
    post.owner?.name,
    post.author?.name,
    post.author,
    post.comet_sections?.content?.story?.actors?.[0]?.name,
    post.node?.actors?.[0]?.name,
    post.story?.actors?.[0]?.name,
  ];

  for (const path of paths) {
    if (path && typeof path === "string") return path;
  }
  return "Unknown";
}

function toUnixSeconds(value) {
  if (value == null) return null;

  if (typeof value === "number") {
    if (value > 1e12) return Math.floor(value / 1000);
    if (value > 1e9) return value;
    return null;
  }

  if (typeof value === "string") {
    const s = value.trim();
    if (!s) return null;

    if (/^\d+$/.test(s)) {
      const n = Number(s);
      if (!Number.isFinite(n)) return null;
      if (n > 1e12) return Math.floor(n / 1000);
      if (n > 1e9) return n;
      return null;
    }

    const ms = Date.parse(s);
    if (!Number.isNaN(ms)) return Math.floor(ms / 1000);

    const fixed = s.replace(/([+-]\d{2})(\d{2})$/, "$1:$2");
    const ms2 = Date.parse(fixed);
    if (!Number.isNaN(ms2)) return Math.floor(ms2 / 1000);

    return null;
  }

  return null;
}

function extractCreatedTime(post) {
  const candidates = [
    post.creation_time,
    post.comet_sections?.content?.story?.creation_time,
    post.comet_sections?.context_layout?.story?.creation_time,
    post.comet_sections?.context_layout?.story?.comet_sections?.content?.story
      ?.creation_time,
    post.comet_sections?.context_layout?.story?.comet_sections?.metadata?.[0]
      ?.story?.creation_time,
    post.node?.creation_time,
    post.story?.creation_time,
    post.edge?.node?.creation_time,
    post.created_time,
    post.publish_time,
    post.timestamp,
    post.attachments?.data?.[0]?.target?.creation_time,
  ];

  for (const v of candidates) {
    const t = toUnixSeconds(v);
    if (t) return t;
  }

  return null;
}

function extractText(post) {
  const paths = [
    post.message?.text,
    post.message,
    post.text,
    post.body,
    post.comet_sections?.content?.story?.message?.text,
    post.story_message?.text,
    post.node?.message?.text,
    post.node?.message,
    post.story?.message?.text,
    post.story?.message,
  ];

  for (const path of paths) {
    if (path && typeof path === "string" && path.trim().length > 0) {
      return path.trim();
    }
  }
  return null;
}

function extractGroup(post) {
  const paths = [
    post.to?.data?.[0]?.name,
    post.to?.name,
    post.group?.name,
    post.feedback?.owning_group?.name,
  ];

  for (const path of paths) {
    if (path && typeof path === "string") return path;
  }
  return null;
}

function extractMedia(post) {
  const media = [];

  function searchMedia(obj, depth = 0) {
    if (!obj || typeof obj !== "object" || depth > 12) return;

    if (obj.image?.uri) media.push({ type: "image", url: obj.image.uri });
    if (obj.image?.url) media.push({ type: "image", url: obj.image.url });
    if (obj.photo?.image?.uri)
      media.push({ type: "image", url: obj.photo.image.uri });
    if (obj.full_width?.uri)
      media.push({ type: "image", url: obj.full_width.uri });
    if (obj.large_image?.uri)
      media.push({ type: "image", url: obj.large_image.uri });

    if (obj.video?.playable_url)
      media.push({ type: "video", url: obj.video.playable_url });
    if (obj.playable_url) media.push({ type: "video", url: obj.playable_url });
    if (obj.playable_url_quality_hd)
      media.push({ type: "video", url: obj.playable_url_quality_hd });
    if (obj.browser_native_hd_url)
      media.push({ type: "video", url: obj.browser_native_hd_url });
    if (obj.browser_native_sd_url)
      media.push({ type: "video", url: obj.browser_native_sd_url });

    if (
      obj.url &&
      typeof obj.url === "string" &&
      (obj.url.includes("fbcdn.net") || obj.url.includes("facebook.com/photo"))
    ) {
      media.push({ type: "image", url: obj.url });
    }

    if (Array.isArray(obj)) {
      obj.forEach((item) => searchMedia(item, depth + 1));
    } else {
      Object.values(obj).forEach((value) => {
        if (value && typeof value === "object") {
          searchMedia(value, depth + 1);
        }
      });
    }
  }

  searchMedia(post);

  const uniqueMedia = [];
  const seen = new Set();
  media.forEach((m) => {
    if (!seen.has(m.url)) {
      seen.add(m.url);
      uniqueMedia.push(m);
    }
  });

  return uniqueMedia;
}

function generateId() {
  return `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

function notifyPosts() {
  const postsArray = Array.from(detectedPosts.values());

  window.postMessage(
    {
      __EXT__: true,
      type: "POSTS_DETECTED",
      payload: { posts: postsArray },
    },
    "*"
  );
}

window.addEventListener("message", (event) => {
  if (event.source !== window) return;
  const message = event.data;
  if (message && message.__EXT__ === true && message.type === "DOWNLOAD") {
    window.postMessage(
      {
        __EXT__: true,
        type: "DOWNLOAD",
        payload: message.payload,
      },
      "*"
    );
  }
});

setInterval(() => {
  if (detectedPosts.size > 0) {
    notifyPosts();
  }
}, 5000);
